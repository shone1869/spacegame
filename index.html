<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Space Shooter (Updated Spaceship)</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column; /* Stack canvas and score */
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #333;
            background-color: #000; /* Black space background */
            display: block; /* Prevents extra space below canvas */
        }
        #scoreBoard {
            margin-top: 10px;
            font-size: 1.5em;
            color: #333;
        }
         #messageBoard {
            position: absolute; /* Position over canvas */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Center it */
            color: red;
            font-size: 3em;
            font-weight: bold;
            text-align: center;
            display: none; /* Hidden initially */
            background-color: rgba(255, 255, 255, 0.7); /* Semi-transparent background */
            padding: 20px;
            border-radius: 10px;
        }
    </style>
</head>
<body>

    <div id="scoreBoard">Score: <span id="score">0</span></div>
    <canvas id="gameCanvas" width="600" height="400"></canvas>
    <div id="messageBoard">GAME OVER</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const messageBoard = document.getElementById('messageBoard');

        let score = 0;
        let gameOver = false;
        let gameLoopId = null; // To store the requestAnimationFrame ID

        // --- Player Settings ---
        const player = {
            x: canvas.width / 2 - 25,
            y: canvas.height - 40,
            width: 50, // Hitbox width
            height: 20, // Hitbox height
            speed: 5,
            dx: 0, // Direction x
            color: 'white' // *** CHANGED color to white ***
        };

        // --- Bullet Settings ---
        const bullets = [];
        const bulletInfo = {
            width: 5,
            height: 10,
            speed: 7,
            color: 'yellow',
            cooldown: 250, // Milliseconds between shots
            lastShotTime: 0
        };

        // --- Enemy Settings ---
        const enemies = [];
        const enemyInfo = {
            rows: 3,
            cols: 8,
            width: 40, // Hitbox width
            height: 20, // Hitbox height
            padding: 15,
            offsetTop: 30,
            offsetLeft: 40,
            speed: 1,
            dropAmount: 25, // How much they drop when hitting edge
            color: 'red'
        };
        let enemyDirection = 1; // 1 for right, -1 for left

        // --- Key Handling ---
        const keys = {
            ArrowLeft: false,
            ArrowRight: false,
            Space: false // Using 'Space' for spacebar
        };

        function keyDownHandler(e) {
            // console.log('Key Down:', e.key);
            const key = e.key === ' ' ? 'Space' : e.key;

            if (key === 'ArrowLeft' || key === 'ArrowRight' || key === 'Space') {
                keys[key] = true;
                if (key === 'Space') {
                    e.preventDefault();
                    // console.log('Spacebar default prevented');
                }
            }
        }

        function keyUpHandler(e) {
            // console.log('Key Up:', e.key);
            const key = e.key === ' ' ? 'Space' : e.key;
            if (key === 'ArrowLeft' || key === 'ArrowRight' || key === 'Space') {
                keys[key] = false;
            }
        }

        document.addEventListener('keydown', keyDownHandler);
        document.addEventListener('keyup', keyUpHandler);

        // --- Game Functions ---

        function createEnemies() {
            enemies.length = 0;
            for (let r = 0; r < enemyInfo.rows; r++) {
                for (let c = 0; c < enemyInfo.cols; c++) {
                    enemies.push({
                        x: enemyInfo.offsetLeft + c * (enemyInfo.width + enemyInfo.padding),
                        y: enemyInfo.offsetTop + r * (enemyInfo.height + enemyInfo.padding),
                        width: enemyInfo.width,
                        height: enemyInfo.height,
                        alive: true
                    });
                }
            }
        }

        // --- UPDATED DRAWING FUNCTIONS ---

        function drawPlayer() {
            // *** UPDATED spaceship shape ***
            const px = player.x;
            const py = player.y;
            const pw = player.width;
            const ph = player.height;

            ctx.beginPath();
            // Nose cone
            ctx.moveTo(px + pw / 2, py); // Top point
            // Right wingtip (slightly back)
            ctx.lineTo(px + pw, py + ph * 0.8);
            // Right engine back
            ctx.lineTo(px + pw * 0.8, py + ph);
            // Center back indent
            ctx.lineTo(px + pw * 0.6, py + ph * 0.8);
            ctx.lineTo(px + pw * 0.4, py + ph * 0.8);
             // Left engine back
            ctx.lineTo(px + pw * 0.2, py + ph);
            // Left wingtip (slightly back)
            ctx.lineTo(px, py + ph * 0.8);
            // Connect back to nose cone
            ctx.closePath();

            ctx.fillStyle = player.color; // Use the updated white color
            ctx.fill();
        }

        function drawEnemies() {
            // Enemy drawing remains the same blocky shape
            enemies.forEach(enemy => {
                if (enemy.alive) {
                    const ey = enemy.y;
                    const ex = enemy.x;
                    const ew = enemy.width;
                    const eh = enemy.height;

                    ctx.beginPath();
                    ctx.moveTo(ex + ew * 0.2, ey);
                    ctx.lineTo(ex + ew * 0.8, ey);
                    ctx.lineTo(ex + ew * 0.8, ey + eh * 0.4);
                    ctx.lineTo(ex + ew, ey + eh * 0.4);
                    ctx.lineTo(ex + ew, ey + eh);
                    ctx.lineTo(ex + ew * 0.7, ey + eh);
                    ctx.lineTo(ex + ew * 0.7, ey + eh * 0.7);
                    ctx.lineTo(ex + ew * 0.3, ey + eh * 0.7);
                    ctx.lineTo(ex + ew * 0.3, ey + eh);
                    ctx.lineTo(ex, ey + eh);
                    ctx.lineTo(ex, ey + eh * 0.4);
                    ctx.lineTo(ex + ew * 0.2, ey + eh * 0.4);
                    ctx.closePath();

                    ctx.fillStyle = enemyInfo.color;
                    ctx.fill();
                }
            });
        }

        // --- END OF UPDATED DRAWING FUNCTIONS ---


        function drawBullets() {
            ctx.fillStyle = bulletInfo.color;
            bullets.forEach(bullet => {
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });
        }


        function drawScore() {
            scoreElement.textContent = score;
        }

        function movePlayer() {
            player.x += player.dx;

            // Wall collision
            if (player.x < 0) {
                player.x = 0;
            } else if (player.x + player.width > canvas.width) {
                player.x = canvas.width - player.width;
            }
        }

        function moveBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].y -= bulletInfo.speed;
                if (bullets[i].y + bulletInfo.height < 0) {
                    bullets.splice(i, 1);
                }
            }
        }

        function moveEnemies() {
            let hitEdge = false;
            enemies.forEach(enemy => {
                if (enemy.alive) {
                    enemy.x += enemyInfo.speed * enemyDirection;
                    if (enemy.x + enemy.width > canvas.width || enemy.x < 0) {
                        hitEdge = true;
                    }
                    if (enemy.y + enemy.height >= player.y - 10) {
                       endGame();
                    }
                }
            });

            if (hitEdge) {
                enemyDirection *= -1;
                enemies.forEach(enemy => {
                    if (enemy.alive) {
                       enemy.y += enemyInfo.dropAmount;
                    }
                });
            }
        }

        function shoot() {
             const now = Date.now();
             const canShoot = now - bulletInfo.lastShotTime > bulletInfo.cooldown;

            if (keys.Space && canShoot) {
                // console.log('Firing bullet!');
                bullets.push({
                    x: player.x + player.width / 2 - bulletInfo.width / 2,
                    y: player.y,
                    width: bulletInfo.width,
                    height: bulletInfo.height
                });
                 bulletInfo.lastShotTime = now;
            }
        }

        function collisionDetection() {
            // Bullet vs Enemy
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (enemy.alive &&
                        bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y)
                    {
                        enemy.alive = false;
                        bullets.splice(i, 1);
                        score += 10;
                        break;
                    }
                }
            }
        }

         function checkWinCondition() {
            const allDead = enemies.every(enemy => !enemy.alive);
            if (allDead && enemies.length > 0) {
                // console.log("You Win!");
                endGame("YOU WIN!");
            }
        }

        function endGame(message = "GAME OVER") {
            if (!gameOver) {
                // console.log("Game Over Triggered:", message);
                gameOver = true;
                messageBoard.textContent = message;
                messageBoard.style.display = 'block';
                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                    gameLoopId = null;
                }
            }
        }

        // --- Update Function (Called every frame) ---
        function update() {
            if (gameOver) return;

            player.dx = 0;
            if (keys.ArrowLeft) {
                player.dx = -player.speed;
            }
            if (keys.ArrowRight) {
                player.dx = player.speed;
            }

            shoot();
            movePlayer();
            moveBullets();
            moveEnemies();
            collisionDetection();
            checkWinCondition();
        }

        // --- Draw Function (Called every frame) ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPlayer();
            drawBullets();
            drawEnemies();
            drawScore();
        }

        // --- Game Loop ---
        function gameLoop() {
            update();
            draw();
            if (!gameOver) {
               gameLoopId = requestAnimationFrame(gameLoop);
            }
        }

        // --- Start Game ---
        // console.log("Initializing game...");
        createEnemies();
        // console.log("Enemies created:", enemies.length);
        gameLoop();
        // console.log("Game loop started.");

    </script>

</body>
</html>
